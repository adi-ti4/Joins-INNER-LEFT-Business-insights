# Joins-INNER-LEFT-Business-insights
Joins (INNER, LEFT)  + Business insights

SQL Query-
USE ecommerce;

SELECT * FROM ecommerce.orders;
SELECT * FROM ecommerce.customers;
SELECT * FROM ecommerce.products;
SELECT * FROM ecommerce.categories;


-- Combines orders with customer details
SELECT 
    o.OrderID,
    o.OrderDate,
    o.ProductCategory,
    o.TotalAmount,
    c.CustomerID,
    c.CustomerName,
    c.Email,
    c.City,
    c.CustomerSegment
FROM orders o
INNER JOIN customers c
ON o.CustomerID = c.CustomerID;

-- Check Total Orders
SELECT COUNT(*) AS Joined_Count
FROM orders o
INNER JOIN customers c
ON o.CustomerID = c.CustomerID;

-- Customers with no orders
SELECT
    c.CustomerID,
    c.CustomerName,
    c.Email,
    c.City,
    c.CustomerSegment,
    c.SignupDate
FROM customers c
LEFT JOIN orders o
ON c.CustomerID = o.CustomerID
WHERE o.CustomerID IS NULL;

-- Revenue per SKU / product, 
-- Total units sold 
-- Sorted highest revenue first
SELECT
    p.ProductID,
    p.SKU,
    p.ProductName,
    p.ProductCategory,
    SUM(o.Quantity) AS Total_Units_Sold,   
    SUM(o.TotalAmount) AS Total_Revenue
FROM orders o
INNER JOIN products p
ON o.ProductName = p.ProductName
GROUP BY
    p.ProductID,
    p.SKU,
    p.ProductName,
    p.ProductCategory
ORDER BY Total_Revenue DESC;


SELECT
    p.SKU,
    p.ProductName,
    SUM(o.TotalAmount) AS Total_Revenue
FROM orders o
JOIN products p
ON o.ProductName = p.ProductName
GROUP BY p.SKU, p.ProductName
ORDER BY Total_Revenue DESC
LIMIT 10;



SELECT
    p.SKU,
    p.ProductName,
    SUM(o.TotalAmount) AS Total_Revenue,
    CASE
        WHEN SUM(o.TotalAmount) >= 80000 THEN 'High Performing'
        WHEN SUM(o.TotalAmount) >= 50000 THEN 'Medium Performing'
        ELSE 'Low Performing'
    END AS Performance_Category
FROM orders o
JOIN products p
ON o.ProductName = p.ProductName
GROUP BY p.SKU, p.ProductName
ORDER BY Total_Revenue DESC;


-- Top 10 High Performing SKUs
SELECT
    p.SKU,
    p.ProductName,
    SUM(o.TotalAmount) AS Total_Revenue
FROM orders o
JOIN products p
ON o.ProductName = p.ProductName
GROUP BY p.SKU, p.ProductName
HAVING SUM(o.TotalAmount) > 80000
ORDER BY Total_Revenue DESC
LIMIT 10;

-- Total revenue generated by each product category
-- Categories sorted from highest to lowest revenue
-- Directly usable for strategy & reporting

SELECT
    c.CategoryID,
    c.CategoryName,
    SUM(o.TotalAmount) AS Total_Revenue
FROM categories c
INNER JOIN products p
    ON c.CategoryName = p.ProductCategory
INNER JOIN orders o
    ON p.ProductName = o.ProductName
GROUP BY
    c.CategoryID,
    c.CategoryName
ORDER BY Total_Revenue DESC;


-- Total Sales in Mumbai From 1 Jan 2023 to 31 Mar 2023
SELECT
    c.City AS Region,
    SUM(o.TotalAmount) AS Total_Sales
FROM orders o
INNER JOIN customers c
ON o.CustomerID = c.CustomerID
WHERE c.City = 'Mumbai'
  AND o.OrderDate BETWEEN '01-01-2023' AND '31-03-2023'
GROUP BY c.City;

-- Final dataset of (Customers, Orders, Products)
SELECT
    o.OrderID,
    o.OrderDate,
    c.CustomerID,
    c.CustomerName,
    c.City AS Customer_Region,
    o.ProductCategory,
    o.ProductName,
    o.Quantity,
    o.TotalAmount
FROM orders o
INNER JOIN customers c
    ON o.CustomerID = c.CustomerID;
    
-- Top Products Drive Majority of Revenue
SELECT
    ProductName,
    SUM(TotalAmount) AS Revenue
FROM orders
GROUP BY ProductName
ORDER BY Revenue DESC
LIMIT 3;

-- Few Regions Generate Maximum Sales
SELECT
    c.City,
    SUM(o.TotalAmount) AS Total_Sales
FROM orders o
JOIN customers c
ON o.CustomerID = c.CustomerID
GROUP BY c.City
ORDER BY Total_Sales DESC;

-- Small Set of Customers Are High-Value Buyers
SELECT
    c.CustomerID,
    c.CustomerName,
    SUM(o.TotalAmount) AS Lifetime_Value
FROM orders o
JOIN customers c
ON o.CustomerID = c.CustomerID
GROUP BY c.CustomerID, c.CustomerName
ORDER BY Lifetime_Value DESC
LIMIT 5;
